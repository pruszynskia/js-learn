Super kierunek ğŸ’ª Grafy to jedna z najwaÅ¼niejszych struktur danych â€” szczegÃ³lnie przydatna w frontendzie (routing, dependency graphs, state machines, wizualizacje, workflow).

PoniÅ¼ej masz:

1ï¸âƒ£ **MapÄ™ zagadnieÅ„ do nauki (kolejnoÅ›Ä‡ sensownej progresji)**
2ï¸âƒ£ **Zestaw Ä‡wiczeÅ„ projektowych (realne use-caseâ€™y)**
3ï¸âƒ£ Ä†wiczenia prowadzÄ… CiÄ™ pytaniami â€” tak, Å¼ebyÅ› sam dochodziÅ‚ do rozwiÄ…zania

ZakÅ‚adamy Twoje interfejsy:

```ts
interface Node {
  id: number;
  label: string;
}

interface Edge {
  source: number;
  target: number;
}
```

---

# ğŸ“š CZÄ˜ÅšÄ† 1 â€” LISTA RZECZY DO NAUKI

## ğŸ”¹ POZIOM 1 â€” Fundamenty

1. Reprezentacje grafu:

   * lista sÄ…siedztwa (adjacency list)
   * macierz sÄ…siedztwa
2. Graf skierowany vs nieskierowany
3. StopieÅ„ wierzchoÅ‚ka (in-degree, out-degree)
4. Sprawdzanie czy graf zawiera krawÄ™dÅº
5. Iterowanie po sÄ…siadach

---

## ğŸ”¹ POZIOM 2 â€” Przeszukiwanie grafu

6. DFS (Depth First Search)
7. BFS (Breadth First Search)
8. Znajdowanie Å›cieÅ¼ki miÄ™dzy dwoma wierzchoÅ‚kami
9. Wykrywanie cyklu

---

## ğŸ”¹ POZIOM 3 â€” Algorytmy praktyczne

10. Sortowanie topologiczne
11. Silnie spÃ³jne skÅ‚adowe
12. NajkrÃ³tsza Å›cieÅ¼ka (BFS â€“ graf niewaÅ¼ony)
13. Dijkstra (graf waÅ¼ony)
14. Sprawdzanie czy graf jest spÃ³jny

---

## ğŸ”¹ POZIOM 4 â€” MyÅ›lenie systemowe

15. Dependency graph
16. Workflow / state machine
17. Graph jako reprezentacja relacji (np. social network)
18. Path finding (routing)
19. Graph traversal w UI (np. drzewo komponentÃ³w)

---

# ğŸ§  CZÄ˜ÅšÄ† 2 â€” Ä†WICZENIA PROJEKTOWE

KaÅ¼de Ä‡wiczenie to:

* ğŸ¯ Kontekst realny
* ğŸ§© Problem do rozwiÄ…zania
* â“ Pytania naprowadzajÄ…ce
* ğŸ’¡ Co powinieneÅ› odkryÄ‡

Wszystko do zrobienia w jednym pliku `.ts`.

---

# ğŸ”¹ Ä†wiczenie 1 â€” â€Znajomi na LinkedInâ€

ğŸ¯ **Realny problem:**
Masz uÅ¼ytkownikÃ³w i relacje "zna".

```ts
const nodes: Node[] = [
  { id: 1, label: "Ania" },
  { id: 2, label: "Bartek" },
  { id: 3, label: "Celina" },
  { id: 4, label: "Daniel" }
];

const edges: Edge[] = [
  { source: 1, target: 2 },
  { source: 2, target: 3 },
  { source: 3, target: 4 }
];
```

---

### ğŸ§© Zadania

1. Zbuduj listÄ™ sÄ…siedztwa.
2. Napisz funkcjÄ™:

   ```ts
   getNeighbors(nodeId: number): number[]
   ```

---

### â“ Pytania

* Czy dla grafu nieskierowanego powinieneÅ› dodaÄ‡ relacjÄ™ w obie strony?
* JakÄ… strukturÄ™ wybraÄ‡? `Map<number, number[]>` czy `Record<number, number[]>`?
* Co siÄ™ stanie jeÅ›li wÄ™zeÅ‚ nie ma sÄ…siadÃ³w?

---

### ğŸ’¡ Co odkryjesz

* Dlaczego lista sÄ…siedztwa jest bardziej efektywna niÅ¼ macierz.
* Jak modelowaÄ‡ relacje.

---

# ğŸ”¹ Ä†wiczenie 2 â€” â€Czy da siÄ™ dojÅ›Ä‡?â€

ğŸ¯ Problem: Czy Ania moÅ¼e dotrzeÄ‡ do Daniela?

---

### ğŸ§© Zadanie

Zaimplementuj BFS.

```ts
function canReach(start: number, target: number): boolean
```

---

### â“ Pytania

* Jak unikniesz nieskoÅ„czonej pÄ™tli?
* Dlaczego potrzebujesz `visited`?
* Dlaczego BFS daje najkrÃ³tszÄ… Å›cieÅ¼kÄ™ w grafie niewaÅ¼onym?

---

### ğŸ’¡ Odkrycie

BFS = eksploracja warstwowa â†’ najkrÃ³tsza Å›cieÅ¼ka.

---

# ğŸ”¹ Ä†wiczenie 3 â€” â€Rekomendacje znajomychâ€

ğŸ¯ Realny problem:
PokaÅ¼ znajomych znajomych (2nd degree connections).

---

### ğŸ§© Zadanie

ZwrÃ³Ä‡ wszystkich uÅ¼ytkownikÃ³w w odlegÅ‚oÅ›ci 2 od danego.

---

### â“ Pytania

* Czy BFS moÅ¼na zatrzymaÄ‡ po okreÅ›lonej gÅ‚Ä™bokoÅ›ci?
* Jak uniknÄ…Ä‡ zwracania startowego uÅ¼ytkownika?

---

### ğŸ’¡ Odkrycie

Graph depth traversal + poziomy BFS.

---

# ğŸ”¹ Ä†wiczenie 4 â€” â€Wykrywanie cyklu (bÅ‚Ä…d w zaleÅ¼noÅ›ciach)â€

ğŸ¯ Realny problem:
Masz system importÃ³w plikÃ³w:

```
A â†’ B
B â†’ C
C â†’ A
```

To powoduje bÅ‚Ä…d bundlera.

---

### ğŸ§© Zadanie

Zaimplementuj wykrywanie cyklu przy uÅ¼yciu DFS.

---

### â“ Pytania

* Dlaczego samo `visited` nie wystarczy?
* Czym jest `recursion stack`?
* Kiedy wykrywasz powrÃ³t do wÄ™zÅ‚a bÄ™dÄ…cego w aktualnej Å›cieÅ¼ce?

---

### ğŸ’¡ Odkrycie

RÃ³Å¼nica miÄ™dzy:

* odwiedzonym
* aktualnie przetwarzanym

To jest klucz do cyklu.

---

# ğŸ”¹ Ä†wiczenie 5 â€” â€KolejnoÅ›Ä‡ budowania projektuâ€

ğŸ¯ Realny problem:
Masz zaleÅ¼noÅ›ci:

```
Core â†’ UI
Core â†’ API
API â†’ App
UI â†’ App
```

W jakiej kolejnoÅ›ci budowaÄ‡?

---

### ğŸ§© Zadanie

Zaimplementuj sortowanie topologiczne.

---

### â“ Pytania

* Co siÄ™ stanie jeÅ›li graf ma cykl?
* Jak wykorzystaÄ‡ in-degree?
* Dlaczego wÄ™zÅ‚y z in-degree 0 sÄ… pierwsze?

---

### ğŸ’¡ Odkrycie

Dependency graph = topological sort.

---

# ğŸ”¹ Ä†wiczenie 6 â€” â€Routing w aplikacjiâ€

ğŸ¯ Realny problem:
Masz mapÄ™ stron:

```
Home â†’ Products
Products â†’ ProductDetails
Home â†’ About
```

Chcesz znaleÅºÄ‡ Å›cieÅ¼kÄ™ od Home do ProductDetails.

---

### ğŸ§© Zadanie

ZwrÃ³Ä‡ najkrÃ³tszÄ… Å›cieÅ¼kÄ™ jako tablicÄ™ ID.

---

### â“ Pytania

* Jak przechowywaÄ‡ â€poprzednikaâ€?
* Dlaczego potrzebujesz mapy `parent`?
* Jak odtworzyÄ‡ Å›cieÅ¼kÄ™ od koÅ„ca?

---

### ğŸ’¡ Odkrycie

BFS + parent map = rekonstrukcja Å›cieÅ¼ki.

---

# ğŸ”¹ Ä†wiczenie 7 â€” â€System workflowâ€

ğŸ¯ Realny problem:

```
Draft â†’ Review â†’ Approved
Review â†’ Rejected â†’ Draft
```

---

### ğŸ§© Zadania

1. Czy graf jest spÃ³jny?
2. Czy moÅ¼na wrÃ³ciÄ‡ do Draft?
3. Czy istnieje Å›cieÅ¼ka z Approved do Draft?

---

### â“ Pytania

* Co oznacza graf skierowany?
* Czy silna spÃ³jnoÅ›Ä‡ oznacza wzajemnÄ… osiÄ…galnoÅ›Ä‡?

---

# ğŸ— BONUS â€” Mini projekt koÅ„cowy

Zbuduj klasÄ™:

```ts
class Graph {
  addNode(node: Node)
  addEdge(edge: Edge)
  getNeighbors(id: number)
  bfs(start: number)
  dfs(start: number)
  hasCycle()
  topologicalSort()
}
```

Zaimplementuj jÄ… w jednym pliku.

---

# ğŸ¯ Jak to najlepiej przerobiÄ‡?

ProponujÄ™ takÄ… Å›cieÅ¼kÄ™:

1. TydzieÅ„ 1 â†’ reprezentacja + BFS + DFS
2. TydzieÅ„ 2 â†’ cykle + topological sort
3. TydzieÅ„ 3 â†’ shortest path + mini projekt

---

JeÅ›li chcesz, moÅ¼emy:

* ğŸš€ zrobiÄ‡ to w formie **serii lekcji krok po kroku**
* ğŸ§  zrobiÄ‡ tryb â€rozwiÄ…zuj â€“ ja tylko zadajÄ™ pytaniaâ€
* ğŸ§© albo mogÄ™ dawaÄ‡ Ci zadania jak na rozmowie rekrutacyjnej (Frontend/System Design)

Jak wolisz pracowaÄ‡?
